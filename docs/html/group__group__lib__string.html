<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Azure Small Device Networking: The EWF string utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Azure Small Device Networking
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">The EWF string utilities<div class="ingroups"><a class="el" href="group__group__lib.html">The EWF Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The EWF string utilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabc35af5096aa314c3423d16259f6b936"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#gabc35af5096aa314c3423d16259f6b936">ewfl_unsigned_to_str</a> (uint32_t u, char *str, uint32_t len)</td></tr>
<tr class="memdesc:gabc35af5096aa314c3423d16259f6b936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an uint32_t to a string.  <a href="group__group__lib__string.html#gabc35af5096aa314c3423d16259f6b936">More...</a><br /></td></tr>
<tr class="separator:gabc35af5096aa314c3423d16259f6b936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455a977f9519d32d324f319600d084e3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#ga455a977f9519d32d324f319600d084e3">ewfl_str_to_unsigned</a> (const char *str)</td></tr>
<tr class="memdesc:ga455a977f9519d32d324f319600d084e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an uint32_t from a string.  <a href="group__group__lib__string.html#ga455a977f9519d32d324f319600d084e3">More...</a><br /></td></tr>
<tr class="separator:ga455a977f9519d32d324f319600d084e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae74ab33f65a29e4dcf8b90a4ed11b199"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#gae74ab33f65a29e4dcf8b90a4ed11b199">ewfl_str_length</a> (const char *str)</td></tr>
<tr class="memdesc:gae74ab33f65a29e4dcf8b90a4ed11b199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the passed NULL terminated string.  <a href="group__group__lib__string.html#gae74ab33f65a29e4dcf8b90a4ed11b199">More...</a><br /></td></tr>
<tr class="separator:gae74ab33f65a29e4dcf8b90a4ed11b199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec68843ae1d93ee0c7be090b0e9c01cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#gaec68843ae1d93ee0c7be090b0e9c01cc">ewfl_str_starts_with</a> (const char *str, const char *prefix_str)</td></tr>
<tr class="memdesc:gaec68843ae1d93ee0c7be090b0e9c01cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for a string start match.  <a href="group__group__lib__string.html#gaec68843ae1d93ee0c7be090b0e9c01cc">More...</a><br /></td></tr>
<tr class="separator:gaec68843ae1d93ee0c7be090b0e9c01cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacede9d9995faaafd552fe1b215d86d77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#gacede9d9995faaafd552fe1b215d86d77">ewfl_str_ends_with</a> (const char *str, const char *suffix_str)</td></tr>
<tr class="memdesc:gacede9d9995faaafd552fe1b215d86d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for a string end match.  <a href="group__group__lib__string.html#gacede9d9995faaafd552fe1b215d86d77">More...</a><br /></td></tr>
<tr class="separator:gacede9d9995faaafd552fe1b215d86d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga439110d3801d3c91edf0b168b44d29d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#ga439110d3801d3c91edf0b168b44d29d7">ewfl_buffer_starts_with</a> (const char *buffer, uint32_t buffer_length, const char *prefix_str, uint32_t prefix_length)</td></tr>
<tr class="memdesc:ga439110d3801d3c91edf0b168b44d29d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a buffer starts with a string.  <a href="group__group__lib__string.html#ga439110d3801d3c91edf0b168b44d29d7">More...</a><br /></td></tr>
<tr class="separator:ga439110d3801d3c91edf0b168b44d29d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f79a22a2e99f43666ac5cef5669840a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#ga5f79a22a2e99f43666ac5cef5669840a">ewfl_buffer_ends_with</a> (const char *buffer, uint32_t buffer_length, const char *suffix_str, uint32_t suffix_length)</td></tr>
<tr class="memdesc:ga5f79a22a2e99f43666ac5cef5669840a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a buffer ends with a string.  <a href="group__group__lib__string.html#ga5f79a22a2e99f43666ac5cef5669840a">More...</a><br /></td></tr>
<tr class="separator:ga5f79a22a2e99f43666ac5cef5669840a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f84f6496162d7c1cd9765326fc9411"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#ga62f84f6496162d7c1cd9765326fc9411">ewfl_buffer_ends_with_wildcard_string</a> (const char *buffer, uint32_t buffer_length, const char *suffix_str, uint32_t suffix_length)</td></tr>
<tr class="memdesc:ga62f84f6496162d7c1cd9765326fc9411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a buffer ends with a string containing wildcards The current version supports question marks '?'to match single characters.  <a href="group__group__lib__string.html#ga62f84f6496162d7c1cd9765326fc9411">More...</a><br /></td></tr>
<tr class="separator:ga62f84f6496162d7c1cd9765326fc9411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6724eb5f2e5f8fd6fd7859999aaad2a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#ga6724eb5f2e5f8fd6fd7859999aaad2a3">ewfl_str_equals_str</a> (const char *str1, const char *str2)</td></tr>
<tr class="memdesc:ga6724eb5f2e5f8fd6fd7859999aaad2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two strings are equal.  <a href="group__group__lib__string.html#ga6724eb5f2e5f8fd6fd7859999aaad2a3">More...</a><br /></td></tr>
<tr class="separator:ga6724eb5f2e5f8fd6fd7859999aaad2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24eafab6c9f95fa4afb61ab7ce562223"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#ga24eafab6c9f95fa4afb61ab7ce562223">ewfl_buffer_equals_buffer</a> (const char *buffer1, const char *buffer2, uint32_t length)</td></tr>
<tr class="memdesc:ga24eafab6c9f95fa4afb61ab7ce562223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two buffers are equal.  <a href="group__group__lib__string.html#ga24eafab6c9f95fa4afb61ab7ce562223">More...</a><br /></td></tr>
<tr class="separator:ga24eafab6c9f95fa4afb61ab7ce562223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c0dc240319c76e7770918e2897e6e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#ga77c0dc240319c76e7770918e2897e6e4">ewfl_str_contains_str</a> (const char *str, const char *substr)</td></tr>
<tr class="memdesc:ga77c0dc240319c76e7770918e2897e6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a string in a substring.  <a href="group__group__lib__string.html#ga77c0dc240319c76e7770918e2897e6e4">More...</a><br /></td></tr>
<tr class="separator:ga77c0dc240319c76e7770918e2897e6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d76ca1966dbfc7bb83823411405f30"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#ga67d76ca1966dbfc7bb83823411405f30">ewfl_str_n_cpy</a> (char *dest, const char *src_str, uint32_t n)</td></tr>
<tr class="memdesc:ga67d76ca1966dbfc7bb83823411405f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies source string to destination buffer and terminates it by NULL.  <a href="group__group__lib__string.html#ga67d76ca1966dbfc7bb83823411405f30">More...</a><br /></td></tr>
<tr class="separator:ga67d76ca1966dbfc7bb83823411405f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e668b5c3583212e14886ece3481025e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#ga5e668b5c3583212e14886ece3481025e">ewfl_str_remove_white_spaces</a> (char *str)</td></tr>
<tr class="memdesc:ga5e668b5c3583212e14886ece3481025e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove leading and trailing white space characters.  <a href="group__group__lib__string.html#ga5e668b5c3583212e14886ece3481025e">More...</a><br /></td></tr>
<tr class="separator:ga5e668b5c3583212e14886ece3481025e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a19d151d16e905a86c432378bebe44"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#ga83a19d151d16e905a86c432378bebe44">ewfl_str_remove_suffix_str</a> (char *str, const char *suffix_str)</td></tr>
<tr class="memdesc:ga83a19d151d16e905a86c432378bebe44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove suffix from string.  <a href="group__group__lib__string.html#ga83a19d151d16e905a86c432378bebe44">More...</a><br /></td></tr>
<tr class="separator:ga83a19d151d16e905a86c432378bebe44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70479f857a34e9336c3b870fd276e112"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lib__string.html#ga70479f857a34e9336c3b870fd276e112">ewfl_adapter_response_str_extract</a> (char *str)</td></tr>
<tr class="memdesc:ga70479f857a34e9336c3b870fd276e112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse adapter response by trimming white space and "OK".  <a href="group__group__lib__string.html#ga70479f857a34e9336c3b870fd276e112">More...</a><br /></td></tr>
<tr class="separator:ga70479f857a34e9336c3b870fd276e112"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The EWF string utilities. </p>
<p>Low footprint string functions to avoid bringing in libraries. Some of these functions are similar to C library functions but are available here to avoid including C standard libraries, this enables some toolchains to further optimize footprint. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga70479f857a34e9336c3b870fd276e112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70479f857a34e9336c3b870fd276e112">&#9670;&nbsp;</a></span>ewfl_adapter_response_str_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ewfl_adapter_response_str_extract </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse adapter response by trimming white space and "OK". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>a pointer to the string from which suffix string will be removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix_str</td><td>a pointer to substring to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the trimmed string. </dd></dl>

</div>
</div>
<a id="ga5f79a22a2e99f43666ac5cef5669840a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f79a22a2e99f43666ac5cef5669840a">&#9670;&nbsp;</a></span>ewfl_buffer_ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ewfl_buffer_ends_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>suffix_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a buffer ends with a string. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer ends with the suffix, false otherwise. </dd></dl>

</div>
</div>
<a id="ga62f84f6496162d7c1cd9765326fc9411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62f84f6496162d7c1cd9765326fc9411">&#9670;&nbsp;</a></span>ewfl_buffer_ends_with_wildcard_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ewfl_buffer_ends_with_wildcard_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>suffix_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a buffer ends with a string containing wildcards The current version supports question marks '?'to match single characters. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer ends with the suffix, false otherwise. </dd></dl>

</div>
</div>
<a id="ga24eafab6c9f95fa4afb61ab7ce562223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24eafab6c9f95fa4afb61ab7ce562223">&#9670;&nbsp;</a></span>ewfl_buffer_equals_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ewfl_buffer_equals_buffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two buffers are equal. </p>
<p>This function is similar to the C library function memcmp but it is available here for completness. Not including C standard libraries that define memcmp will allow some toolchains to further optimize footprint. Note that the return of this function and memcmp are different, opposite. memcmp will return zero if both strings are equal, this function will return true if both strings are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer1</td><td>a pointer to a buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer2</td><td>a pointer to a buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the length to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both strings are equal, false if they are different. </dd></dl>

</div>
</div>
<a id="ga439110d3801d3c91edf0b168b44d29d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga439110d3801d3c91edf0b168b44d29d7">&#9670;&nbsp;</a></span>ewfl_buffer_starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ewfl_buffer_starts_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prefix_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a buffer starts with a string. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer starts with the prefix, false otherwise. </dd></dl>

</div>
</div>
<a id="ga77c0dc240319c76e7770918e2897e6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c0dc240319c76e7770918e2897e6e4">&#9670;&nbsp;</a></span>ewfl_str_contains_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ewfl_str_contains_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for a string in a substring. </p>
<p>This function is similar to the C library function strstr but it is available here for completness. Not including C standard libraries that define strstr will allow some toolchains to further optimize footprint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>a pointer to a NULL terminated string that will be searched </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">substr</td><td>a sub-string pattern that will be looked for in str. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the substr is found in str, false otherwise. </dd></dl>

</div>
</div>
<a id="gacede9d9995faaafd552fe1b215d86d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacede9d9995faaafd552fe1b215d86d77">&#9670;&nbsp;</a></span>ewfl_str_ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ewfl_str_ends_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for a string end match. </p>
<p>Note that the order of parameters in this function is not interchangeable. The first parameter is the string that will be matched and the second one the suffix that will be looked for in that string. Typically, the terminator will be shorted than the string that is being matched, if it is longer there will be no match, the function will return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>a pointer to a NULL terminated string that will be matched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix_str</td><td>the prefix that will be looked for at the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the string ends with the terminator string, false otherwise. </dd></dl>

</div>
</div>
<a id="ga6724eb5f2e5f8fd6fd7859999aaad2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6724eb5f2e5f8fd6fd7859999aaad2a3">&#9670;&nbsp;</a></span>ewfl_str_equals_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ewfl_str_equals_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two strings are equal. </p>
<p>This function is similar to the C library function strcmp but it is available here for completness. Not including C standard libraries that define strcmp will allow some toolchains to further optimize footprint. Note that the return of this function and strcmp are different, opposite. strcmp will return zero if both strings are equal, this function will return true if both strings are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str1</td><td>a pointer to a NULL terminated string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str2</td><td>a pointer to a NULL terminated string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both strings are equal, false if they are different. </dd></dl>

</div>
</div>
<a id="gae74ab33f65a29e4dcf8b90a4ed11b199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae74ab33f65a29e4dcf8b90a4ed11b199">&#9670;&nbsp;</a></span>ewfl_str_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ewfl_str_length </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the passed NULL terminated string. </p>
<p>This function is equivalent to the C library strlen but it is available here for completness. Not including C standard libraries that define strlen will allow some toolchains to further optimize footprint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>pointer to a NULL terminated string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uint32_t length of the passed string. </dd></dl>

</div>
</div>
<a id="ga67d76ca1966dbfc7bb83823411405f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67d76ca1966dbfc7bb83823411405f30">&#9670;&nbsp;</a></span>ewfl_str_n_cpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ewfl_str_n_cpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies source string to destination buffer and terminates it by NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>a pointer to the destination buffer where the source string will be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_str</td><td>a pointer to a NULL terminated string that will be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of bytes that will be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the substr is found in str, false otherwise. </dd></dl>

</div>
</div>
<a id="ga83a19d151d16e905a86c432378bebe44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83a19d151d16e905a86c432378bebe44">&#9670;&nbsp;</a></span>ewfl_str_remove_suffix_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ewfl_str_remove_suffix_str </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove suffix from string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>a pointer to the string from which suffix string will be removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix_str</td><td>a pointer to substring to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the trimmed string. </dd></dl>

</div>
</div>
<a id="ga5e668b5c3583212e14886ece3481025e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e668b5c3583212e14886ece3481025e">&#9670;&nbsp;</a></span>ewfl_str_remove_white_spaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ewfl_str_remove_white_spaces </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove leading and trailing white space characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>a pointer to the string that will be trimmed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the trimed string. </dd></dl>

</div>
</div>
<a id="gaec68843ae1d93ee0c7be090b0e9c01cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec68843ae1d93ee0c7be090b0e9c01cc">&#9670;&nbsp;</a></span>ewfl_str_starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ewfl_str_starts_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for a string start match. </p>
<p>Note that the order of parameters in this function is not interchangeable. The first parameter is the string that will be matched and the second one the prefix that will be looked for in that string. Typically, the prefix will be shorted than the string that is being matched, if it is longer there will be no match, the function will return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>a pointer to a NULL terminated string that will be matched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_str</td><td>the prefix that will be looked for at the begining of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the string starts with the prefix, false otherwise. </dd></dl>

</div>
</div>
<a id="ga455a977f9519d32d324f319600d084e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga455a977f9519d32d324f319600d084e3">&#9670;&nbsp;</a></span>ewfl_str_to_unsigned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ewfl_str_to_unsigned </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an uint32_t from a string. </p>
<p>This function will attempt to parse an uint32_t out of the passed string. If the string is NULL, 0 is returned. The string will be parsed until the first non digit character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>a pointer to a NULL terminated string to be parsed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an uint32_t value parsed from the string </dd></dl>

</div>
</div>
<a id="gabc35af5096aa314c3423d16259f6b936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc35af5096aa314c3423d16259f6b936">&#9670;&nbsp;</a></span>ewfl_unsigned_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ewfl_unsigned_to_str </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an uint32_t to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>and uint32_t to be converted into a string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">str</td><td>a pointer to a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a static buffer with the string representation of the passed uint32_t. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
